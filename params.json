{"name":"QuiXDM","tagline":"QuiXDM is an open-source implementation of an XML and JSON able to do Streaming Processing","body":"# QuiXDM\r\n**QuiXDM** is an *ubiquituous* open-source datamodel to process in a Streaming fashion:\r\n* [x] XML (via [XQuery and XPath Data Model (XDM)](http://www.w3.org/TR/xpath-datamodel/)) \r\n* [x] JSON \r\n  * [ ] YAML\r\n* [x] RDF Triple \r\n  * [ ] Quad\r\n* [x] CSV\r\n  * [ ] TSV\r\n* [ ] HTML\r\n\r\n[![Build Status](https://travis-ci.org/innovimax/QuiXDM.svg?branch=master)](https://travis-ci.org/innovimax/QuiXDM)\r\n[![Coverity Scan Build Status](https://scan.coverity.com/projects/6518/badge.svg)](https://scan.coverity.com/projects/6518)\r\n# Getting Started\r\n\r\nTo install it\r\n*  Checkout this code. It's Java 1.8+ compliant\r\n*  Get access to Saxon 9.6: http://saxon.sourceforge.net/\r\n*  Get access to Jackson Core 2.6.2: https://github.com/FasterXML/jackson-core \r\n\r\n# Why QuiXDM?\r\nThere is SAX and StAX and DOM out there for processing XML\r\n\r\n Feature\\API | SAX | StAX | DOM | Jackson | **QuiXDM**\r\n------|-----|------|-----|-------|----\r\nin memory/streaming | streaming | streaming | in memory | streaming | **streaming**\r\npush/pull | push | pull | -- | pull | **pull**\r\ndata model | low level XML | low level XML | low level XML | low level JSON | **XPath Data Model**\r\nhandle sequence | no | no | no | no | **yes**\r\nhandle json/yaml | no | no | no | yes | **yes**\r\nhandle rdf  | no | no | no | no  | **yes**\r\nhandle csv  | no | no | no | no  | **yes**\r\nhandle html | no | no | no | no  | **yes**\r\n\r\n# How does it work?\r\nIt uses a consistent datamodel to represent all those contents in streaming.\r\n\r\n```ANTLR\r\n// Here is the grammar of events\r\nsequence       := START_SEQUENCE, (document|json_yaml|table|semantic)*, END_SEQUENCE\r\ndocument       := START_DOCUMENT, (PROCESSING-INSTRUCTION|COMMENT)*, element, (PROCESSING-INSTRUCTION|COMMENT)*, END_DOCUMENT\r\njson_yaml      := START_JSON, object, END_JSON\r\ntable          := START_TABLE, header*, array_of_array, END_TABLE\r\nsemantic       := START_RDF, statement*, END_RDF\r\nelement        := START_ELEMENT, (NAMESPACE|ATTRIBUTE)*, (TEXT|element|PROCESSING-INSTRUCTION|COMMENT)*, END_ELEMENT\r\nobject         := START_OBJECT, (KEY_NAME, value)*, END_OBJECT\r\nvalue          := object|array|flat_value\r\nflat_value     := VALUE_FALSE|VALUE_TRUE|VALUE_NUMBER|VALUE_NULL|VALUE_STRING\r\narray          := START_ARRAY, value*, END_ARRAY\r\narray_of_array := START_ARRAY, flat_array+, END_ARRAY\r\nflat_array     := START_ARRAY, flat_value*, END_ARRAY\r\nstatement      := START_PREDICATE, SUBJECT, OBJECT, GRAPH?, END_PREDICATE\r\n```\r\nMostly look at [QuiXToken.java](https://github.com/innovimax/QuiXDM/blob/master/src/main/java/innovimax/quixproc/datamodel/QuiXToken.java)\r\n\r\n# Use\r\n## With Object creation (à la [javax.xml.stream.XMLEventReader](https://docs.oracle.com/javase/8/docs/api/index.html?javax/xml/stream/XMLEventReader.html))\r\nSimplest way to use, is to instantiate [innovimax.quixproc.datamodel.in.QuiXEventStreamReader.java](https://github.com/innovimax/QuiXDM/blob/master/src/main/java/innovimax/quixproc/datamodel/in/QuiXEventStreamReader.java)\r\n```java\r\nIterable<Source> sources = Arrays.asList(new Source[] {\r\n\t\tnew javax.xml.transform.stream.StreamSource(\"/tmp/file/file_aaa.xml\"),\t\r\n\t\tnew javax.xml.transform.stream.StreamSource(\"/tmp/file/file_aab.xml\")\t\r\n});\r\nQuiXEventStreamReader qesr = new QuiXEventStreamReader(sources);\r\nwhile(qesr.hasNext()) {\r\n\tSystem.out.println(qesr.next());\r\n}\r\n```\r\n## Lightweight iterator without Object creation (à la [javax.xml.stream.XMLStreamReader](https://docs.oracle.com/javase/8/docs/api/index.html?javax/xml/stream/XMLStreamReader.html))\r\n***TODO***\r\n\r\n\r\n\r\n# Why [QuiXCharStream](https://github.com/innovimax/QuiXDM/blob/master/src/main/java/innovimax/quixproc/datamodel/QuiXCharStream.java) and [QuiXQName](https://github.com/innovimax/QuiXDM/blob/master/src/main/java/innovimax/quixproc/datamodel/QuiXQName.java)?\r\nWell it comes from the fact that Streaming interface in XML should really be streaming.\r\nThe truth is that there is no such character streaming interface in Java.\r\n * String is definitely not streamable and limited to 2^31 characters\r\n * CharSequence, which could have been, is neither because it has [length()](http://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html#length--)\r\n * CharIterator doesn't exist in the JDK (but you can find it [here](http://fastutil.di.unimi.it/docs/it/unimi/dsi/fastutil/chars/CharIterator.html))\r\n * CharSequence.chars() returns IntStream (instead of CharStream because Java 8 people didn't want to add it) which \r\n * Java 8 Stream<Char> implies that every char is boxed (which means it's highly INEFFICIENT)\r\n \r\nHaving such context, that's why [QuiXCharStream](https://github.com/innovimax/QuiXDM/blob/master/src/main/java/innovimax/quixproc/datamodel/QuiXCharStream.java) and [QuiXQName](https://github.com/innovimax/QuiXDM/blob/master/src/main/java/innovimax/quixproc/datamodel/QuiXQName.java) went live in order to :\r\n * be able to address the TEXT recombination issue (text() node in XDM cannot be contiguous)\r\n * be able to stream even corner cases XML:\r\n   * huge string\r\n   * huge names\r\n   * huge namespace uris\r\n\r\n# Contributors\r\n[Innovimax](http://innovimax.fr) and [INRIA Lille](http://www.inria.fr/centre/lille) is contributing to this work\r\n# Related Projects\r\nQuiXDM can be used standalone\r\n\r\nThis is the data model of QuiXPath and QuiXProc\r\n\r\nIt is part of two bigger projects :\r\n\r\n*  QuiXProc: https://github.com/innovimax/quixproc\r\n*  QuiXPath: https://github.com/innovimax/quixpath\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}